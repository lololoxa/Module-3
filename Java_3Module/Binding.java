package Java_3Module;

public class Binding {
/*=============================== Bonding ================================
    Раннее и позднее связывание отличаются времением, когда компилятор или интерпретатор определяет,
какой именно метод или функция будет вызвана. Эти концепции тесно связаны с полиморфизмом и наследованием.

        Раннее связывание (Early Binding)

    Раннее связывание, также известное как статическое связывание, происходит во время компиляции.
В этом случае компилятор заранее знает, какой метод или функция будет вызвана, исходя из типа объекта.
Это означает, что все вызовы методов и доступы к переменным проверяются на этапе компиляции, и любые ошибки,
связанные с типами, будут обнаружены до выполнения программы.

    Преимущества раннего связывания:
    - Быстродействие: Поскольку все решения о вызове методов принимаются на этапе компиляции, время выполнения уменьшается.
    - Типобезопасность: Компилятор может обнаружить ошибки, связанные с типами, на раннем этапе.

        Позднее связывание (Late Binding)

    Позднее связывание, или динамическое связывание, происходит во время выполнения программы.
    В этом случае решение о том, какой метод или функция будет вызвана, принимается в момент выполнения,
исходя из фактического типа объекта, а не из типа, указанного в коде. Это позволяет объектам разных классов,
имеющих одинаковые интерфейсы (например, методы с одинаковыми именами), быть обработанными одинаково,
что является основой полиморфизма.

    Преимущества позднего связывания:
    - Гибкость: Программа может работать с объектами, чьи типы не были известны на момент компиляции,
что позволяет создавать более модульные и расширяемые системы.
    - Поддержка полиморфизма: Позволяет вызывать переопределенные методы подклассов,
не зная точного типа объекта во время компиляции.*/

    class Animal {
        void sound() {
            System.out.println("Животное издает звук");
        }
    }

    class Dog extends Animal {
        // Позднее связывание
        @Override
        void sound() {
            System.out.println("Собака лает");
        }
    }

    public class Test {
        public static void main(String[] args) {
            Animal myAnimal = new Dog();
            myAnimal.sound(); // Вызовет метод sound класса Dog во время выполнения
        }
    }
}